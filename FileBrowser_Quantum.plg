<?xml version='1.0' standalone='yes'?>

<!DOCTYPE PLUGIN [
<!ENTITY name      "FileBrowser_Quantum">
<!ENTITY author    "YourName">
<!ENTITY version   "2026.01.07">
<!ENTITY pluginURL "https://raw.githubusercontent.com/你的仓库/main/&name;.plg">
<!ENTITY plugin    "/boot/config/plugins/&name;">
<!ENTITY appdata   "/mnt/user/appdata/&name;">
<!ENTITY bin       "/usr/local/sbin">
]>

<PLUGIN name="&name;" author="&author;" version="&version;" pluginURL="&pluginURL;" min="6.9.0">

<CHANGES>
###2026.01.07
- 哨兵模式：支持全量 AppData 固化与阵列启动自动点火。
- 动态解析：自动从 config.yaml 提取运行参数。
- 模块化：彻底分离系统文件与用户数据，支持无损更新。
</CHANGES>

<FILE Run="/bin/bash">
<INLINE>
  mkdir -p &plugin;
  mkdir -p &plugin;/bin
</INLINE>
</FILE>

<FILE Name="&plugin;/filebrowser.tar.gz">
<URL>https://github.com/filebrowser/filebrowser/releases/download/v2.30.0/linux-amd64-filebrowser.tar.gz</URL>
</FILE>

<FILE Name="/etc/rc.d/rc.&name;" Mode="0755">
<INLINE>
#!/bin/bash
# --- 变量定义 ---
APP_DATA="&appdata;"
CONF_FILE="$APP_DATA/config.yaml"
TEMPLATE="&plugin;/config.yaml.template"
BINARY="&bin;/filebrowser"
LOG_FILE="$APP_DATA/log/execution.log"

# --- 工具函数：解析 YAML ---
# 这样即使你改了端口或数据库名，脚本也能自动识别
get_yaml_val() {
    local key=$1
    if [ -f "$CONF_FILE" ]; then
        grep "^  $key:" "$CONF_FILE" | awk -F': ' '{print $2}' | tr -d '"' | tr -d ' '
    fi
}

# --- 核心启动逻辑 ---
filebrowser_start() {
    if pgrep -x "filebrowser" > /dev/null; then
        echo "FileBrowser 已经在运行中。"
        exit 0
    fi

    echo "启动后台哨兵..."
    (
        # 1. 等待阵列挂载
        echo "$(date): 哨兵 - 等待阵列挂载..." >> /var/log/syslog
        while [ ! -d "/mnt/user" ]; do
            sleep 5
        done

        # 2. 初始化 AppData 目录结构
        if [ ! -d "$APP_DATA" ]; then
            mkdir -p "$APP_DATA"
            mkdir -p "$APP_DATA/log"
            mkdir -p "$APP_DATA/tmp"
        fi

        # 3. 配置文件初始化
        if [ ! -f "$CONF_FILE" ]; then
            if [ -f "$TEMPLATE" ]; then
                cp "$TEMPLATE" "$CONF_FILE"
                echo "哨兵 - 首次启动，已从 U 盘同步模板" >> /var/log/syslog
            else
                echo "错误：找不到配置模板" >> /var/log/syslog
                exit 1
            fi
        fi

        # 4. 再次等待数据库文件所在的路径完全可见
        # 我们从 YAML 里动态读数据库位置，而不是写死
        DB_PATH=$(get_yaml_val "database")
        if [ -n "$DB_PATH" ]; then
            while [ ! -f "$DB_PATH" ] &amp;&amp; [ ! -d "/mnt/user" ]; do
                echo "哨兵 - 等待数据库文件就绪: $DB_PATH" >> /var/log/syslog
                sleep 5
            done
        fi

        # 5. 点火
        echo "哨兵 - 阵列已就绪，正在点火启动程序..." >> /var/log/syslog
        cd "$APP_DATA"
        nohup "$BINARY" -c "$CONF_FILE" >> "$LOG_FILE" 2>&1 &
        
        # 验证是否启动成功
        sleep 2
        if pgrep -x "filebrowser" > /dev/null; then
            echo "FileBrowser 启动成功，PID: $(pgrep -x filebrowser)" >> /var/log/syslog
        else
            echo "FileBrowser 启动失败，请检查 $LOG_FILE" >> /var/log/syslog
        fi
    ) &
}

filebrowser_stop() {
    echo "正在停止 FileBrowser..."
    # 使用优雅停止
    pid=$(pgrep -x "filebrowser")
    if [ -n "$pid" ]; then
        kill "$pid"
        sleep 2
        # 如果还没死，强杀
        kill -9 "$pid" > /dev/null 2>&1
    fi
}

filebrowser_status() {
    if pgrep -x "filebrowser" > /dev/null; then
        port=$(get_yaml_val "port")
        echo "FileBrowser 正在运行，监听端口: ${port:-未知}"
    else
        echo "FileBrowser 未运行。"
    fi
}

case "$1" in
    'start')   filebrowser_start ;;
    'stop')    filebrowser_stop ;;
    'restart') filebrowser_stop; sleep 2; filebrowser_start ;;
    'status')  filebrowser_status ;;
    *) echo "Usage: $0 {start|stop|restart|status}" ;;
esac
</INLINE>
</FILE>

<FILE Run="/bin/bash">
<INLINE>
  # 释放二进制文件
  tar -zxf &plugin;/filebrowser.tar.gz -C &bin;/ filebrowser
  chmod +x &bin;/filebrowser

  # 如果 U 盘里没有模板，生成一个初始模板
  if [ ! -f "&plugin;/config.yaml.template" ]; then
cat &lt;&lt;EOF > "&plugin;/config.yaml.template"
server:
  port: 8081
  baseURL: "/"
  address: "0.0.0.0"
  database: "&appdata;/database.db"
  log: "&appdata;/log/execution.log"
userDefaults:
  scope: "/mnt"
EOF
  fi

  # 启动服务
  /etc/rc.d/rc.&name; start

  echo "----------------------------------------------------"
  echo " &name; 安装完成！"
  echo " 哨兵已在后台启动，将自动检测阵列挂载情况。"
  echo "----------------------------------------------------"
</INLINE>
</FILE>

<FILE Run="/bin/bash" Method="remove">
<INLINE>
  /etc/rc.d/rc.&name; stop
  rm -f &bin;/filebrowser
  rm -f /etc/rc.d/rc.&name;
  # 保持 AppData 目录完整，不进行删除
  echo "插件系统文件已移除。您的数据和配置保留在 &appdata;"
</INLINE>
</FILE>

</PLUGIN>
